#include<iostream>
using namespace std;

template <typename T>
class node {
    T data;
    node<T>* next_node;
public:
    node(T d = T(), node<T>* nx = nullptr) {
        data = d;
        next_node = nx;
    }
    node<T>* next() const {
        return next_node;
    }
    T retrieve() {
        return data;
    }
    void setnext(node<T>* nn) {
        next_node = nn;
    }
};

template <typename T>
class list {
    node<T>* head;
public:
    list() {
        head = nullptr;
    }

    bool empty() {
        return (head == nullptr);
    }

    void push_front(T a) {
        if (empty()) {
            head = new node<T>(a, nullptr);
        }
        else {
            head = new node<T>(a, head);
        }
    }

    void pop_front() {
        if (empty()) {
            throw "underflow";
        }
        node<T>* temp = head;
        head = head->next();
        delete temp;
    }

    void display() {
        for (node<T>* ptr = head; ptr != nullptr; ptr = ptr->next()) {
            cout << ptr->retrieve() << "\t";
        }
        cout << "\n";
    }

    void pop_back() {

        if (empty()) {
            throw "underflow";
        }

        if (head->next() == nullptr) {
            delete head;
            head = nullptr;
            return;
        }

        node<T>* temp = head;

        for (node<T>* ptr = head; ptr->next() != nullptr; ptr = ptr->next()) {
            temp = ptr;
        }

        node<T>* del = temp->next();
        temp->setnext(nullptr);
        delete del;
    }

    void push_back(T c) {
        if (empty()) {
            head = new node<T>(c, nullptr);
            return;
        }

        node<T>* temp = head;

        for (node<T>* ptr = head; ptr != nullptr; ptr = ptr->next()) {
            temp = ptr;
        }

        node<T>* a = new node<T>(c, nullptr);
        temp->setnext(a);
    }

    int count(T a) {
        int count = 0;
        for (node<T>* ptr = head; ptr != nullptr; ptr = ptr->next()) {
            if (ptr->retrieve() == a) {
                count++;
            }
        }
        return count;
    }

    void erase_in_between(T n) {
        if (empty()) {
            cout << "List is empty.\n";
            return;
        }

        if (head->retrieve() == n) {
            pop_front();
            return;
        }

        node<T>* prev = nullptr;
        node<T>* ptr = head;

        for (ptr = head; ptr != nullptr; ptr = ptr->next()) {
            if (ptr->retrieve() == n) {
                break;
            }
            prev = ptr;
        }

        if (ptr == nullptr) {
            cout << "Element not found.\n";
            return;
        }

        prev->setnext(ptr->next());
        delete ptr;
    }

    T front() {
        if (empty()) {
            throw "underflow";
        }
        return head->retrieve();
    }
};

template <typename T>
class Queue {
private:
    list<T> L;

public:
    bool empty() {
        return L.empty();
    }

    void enqueue(T x) {
        L.push_back(x);
    }

    void dequeue() {
        if (L.empty()) {
            throw "Underflow";
        }
        L.pop_front();
    }

    T front() {
        if (L.empty()) {
            throw "Underflow";
        }
        return L.front();
    }

    void display() {
        cout << "Queue (front â†’ rear): ";
        L.display();
    }
};

int main() {
    Queue<int> q1;
    q1.enqueue(10);
    q1.enqueue(20);
    q1.enqueue(30);
    q1.display();

    Queue<string> q2;
    q2.enqueue("Ali");
    q2.enqueue("Bilal");
    q2.display();

    return 0;
}
