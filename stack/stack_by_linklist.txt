#include<iostream>

using namespace std;

class node {
	int data;
	node* next_node;
public:
	node(int d = 0, node* nx = nullptr) {
		data = d;
		next_node = nx;
	}
	node* next() const {
		return next_node;
	}
	int retrieve() {
		return data;
	}
	void setnext(node* nn) {
		next_node = nn;
	}
};

class list {
	node* head;
public:
	list()
	{
		head = nullptr;
	}
	bool empty() {
		return (head == nullptr);
	}
	void push_front(int a) {
		if (empty()) {
			head = new node(a, nullptr);
		}
		else {
			head = new node(a, head);

		}
	}

	void pop_front() {
		if (empty()) {
			throw "underflow";
		}
		node* temp = head;
		head = head->next();

		delete temp;
		temp = nullptr;
	}
	void display() {

		for (node* ptr = head; ptr != nullptr; ptr = ptr->next()) {
			cout << ptr->retrieve() << "\t";
		}
		cout << "\n";
	}
	void pop_back() {

		node* temp = head;

		for (node* ptr = head; ptr->next() != nullptr; ptr = ptr->next()) {
			temp = ptr;
		}

		node* del = temp->next();

		temp->setnext(nullptr);
		delete del;
		del = nullptr;


	}
	void push_back(int c) {
		node* temp = head;

		for (node* ptr = head; ptr != nullptr; ptr = ptr->next()) {
			temp = ptr;

		}
		node* a = new node(c, nullptr);
		temp->setnext(a);
	}

	int count(int a) {

		int count = 0;
		for (node* ptr = head; ptr != nullptr; ptr = ptr->next()) {
			
			if (ptr->retrieve() == a) {
				count += 1;
			}
		}
		return count;
	}

	void erase_in_between(int n) {
		if (empty()) {
			cout << "List is empty.\n";
			return;
		}
		if (head->retrieve() == n) {
			pop_front();
			return;
		}
		node* prev = nullptr;
		node* ptr = head;
		for (ptr = head; ptr!= nullptr; ptr= ptr->next()) {
			if (ptr->retrieve() == n) {
				break;
			}
			prev = ptr;
		}

		if (ptr == nullptr) {
			cout << "Element not found.\n";
			return;
		}

		prev->setnext(ptr->next());
		delete ptr;
		ptr= nullptr;
	}
int front() {
    if (empty()) {
        throw "List is empty";
    }
    return head->retrieve();
}

	
};
class Stack {
private:
    list L;      // using your linked list

public:
    bool empty() {
        return L.empty();
    }

    void push(int x) {
        L.push_front(x);      // use your list function
    }

    void pop() {
        L.pop_front();        // use your list function
    }

    int top() {
        return L.front();     // helper function to access head data
    }

    void display() {
        cout << "Stack (top â†’ bottom): ";
        L.display();          // directly call your list display
    }
};

